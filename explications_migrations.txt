# Explications des Migrations - Plateforme Eat&Drink

Ce fichier explique le rôle et la structure de chaque migration créée pour le projet.

---

## 1. users
- **id** : Clé primaire auto-incrémentée.
- **nom_entreprise** : Nom de l'entreprise de l'utilisateur (nullable, car l'admin n'en a pas forcément).
- **email** : Email unique de connexion.
- **password** : Mot de passe hashé.
- **role** : Rôle de l'utilisateur :
    - `admin` : Administrateur
    - `entrepreneur_en_attente` : Demande de stand en attente
    - `entrepreneur_approuve` : Entrepreneur approuvé
- **timestamps** : Champs Laravel (`created_at`, `updated_at`).

## 2. stands
- **id** : Clé primaire auto-incrémentée.
- **nom_stand** : Nom du stand.
- **description** : Description du stand (optionnelle).
- **user_id** : Référence à l'utilisateur propriétaire (clé étrangère).
- **timestamps** : Champs Laravel.

## 3. produits
- **id** : Clé primaire auto-incrémentée.
- **nom** : Nom du produit.
- **description** : Description du produit (optionnelle).
- **prix** : Prix du produit (décimal).
- **image_url** : URL de l'image du produit (optionnelle).
- **stand_id** : Référence au stand auquel appartient le produit (clé étrangère).
- **timestamps** : Champs Laravel.

## 4. commandes
- **id** : Clé primaire auto-incrémentée.
- **stand_id** : Stand concerné par la commande (clé étrangère).
- **details_commande** : Détail des produits commandés (texte ou JSON).
- **date_commande** : Date/heure de la commande (par défaut à la création).
- **timestamps** : Champs Laravel.

---

Chaque table est reliée par des clés étrangères pour garantir l'intégrité référentielle. Les suppressions en cascade (`onDelete('cascade')`) assurent qu'en cas de suppression d'un utilisateur ou d'un stand, les éléments dépendants sont également supprimés.

Les noms de champs et types sont pensés pour répondre strictement au cahier des charges du projet.

---

# Création des Modèles Eloquent

## Commandes utilisées

Pour générer les modèles Eloquent Stand, Produit, Commande :

```
php artisan make:model Stand
php artisan make:model Produit
php artisan make:model Commande
```

Le modèle User existe déjà par défaut dans Laravel, mais il sera adapté pour refléter les nouveaux champs et relations.

---

## Explications détaillées

### 1. Stand (app/Models/Stand.php)
- Représente un stand sur la plateforme.
- Lié à un utilisateur (propriétaire du stand).
- A plusieurs produits associés.

### 2. Produit (app/Models/Produit.php)
- Représente un produit proposé par un stand.
- Lié à un stand (appartenance).

### 3. Commande (app/Models/Commande.php)
- Représente une commande passée pour un stand.
- Contient le détail des produits commandés (stocké sous forme de texte ou JSON).
- Lié à un stand.

### 4. User (app/Models/User.php)
- Adapté pour ajouter les relations avec Stand.
- Dispose des champs supplémentaires (nom_entreprise, role).

---

Chaque modèle sera configuré pour les relations (hasMany, belongsTo) et les champs protégés/assignables. Voir la suite du fichier pour les détails de chaque modèle.

---

# Mise en place de l'authentification Laravel

## Commande utilisée

Pour installer le système d'authentification Laravel Breeze (léger et adapté à une base personnalisée) :

```
composer require laravel/breeze --dev
php artisan breeze:install
npm install && npm run dev
php artisan migrate
```

---

## Explications

- **Laravel Breeze** fournit un système d'authentification simple (inscription, connexion, déconnexion, mot de passe oublié) prêt à l'emploi et facilement personnalisable.
- Après installation, tu auras des routes, contrôleurs, vues Blade et tout le nécessaire pour gérer l'authentification de base.
- Les migrations sont déjà prêtes, donc la commande `php artisan migrate` mettra à jour la base si besoin.
- Il sera ensuite possible d'adapter les vues et contrôleurs pour gérer les rôles et statuts spécifiques du projet.

---

## Choix de la stack Breeze et étapes d'installation

- **Stack choisie** : Blade avec Alpine (recommandée pour une interface classique Laravel, simple à personnaliser, adaptée à un projet pédagogique et à la majorité des besoins d'administration et d'inscription).
- **Dark mode** : Oui (offre une meilleure expérience utilisateur moderne).
- **Testing framework** : Pest ou PHPUnit (choix par défaut accepté, non bloquant pour la suite).

**Rappel** :
- Il faut commenter la ligne `require __DIR__.'/auth.php';` dans `routes/web.php` si le fichier n'existe pas encore, puis la décommenter après installation de Breeze.
- Après installation, les routes, vues et contrôleurs d'authentification sont prêts à l'emploi.

---

## Prochaine étape

Nous allons maintenant personnaliser l'inscription pour gérer le statut "en attente d'approbation" pour les entrepreneurs, et préparer le seed pour l'admin.

La suite du fichier détaillera les adaptations nécessaires pour les rôles et statuts après installation de Breeze.

---

## Personnalisation de l'inscription : nom entreprise et rôle

- **Ajout champ Nom de l'entreprise** :
    - Dans la vue `resources/views/auth/register.blade.php`, on a ajouté un champ obligatoire `nom_entreprise` pour que chaque entrepreneur renseigne le nom de sa société lors de l'inscription.
- **Validation côté contrôleur** :
    - Dans `RegisteredUserController`, on a ajouté la validation du champ `nom_entreprise`.
- **Forçage du rôle** :
    - Lors de la création du nouvel utilisateur, le champ `role` est forcé à la valeur `entrepreneur_en_attente`.
    - Ainsi, toute nouvelle inscription doit être validée par un administrateur avant d'accéder aux fonctionnalités entrepreneur.

Ce comportement garantit que la logique d'approbation/validation des entrepreneurs est respectée dès l'inscription.

---

## Validation des entrepreneurs par l'admin (Back-end)

1. **Création du contrôleur AdminController**
    - Fichier : `app/Http/Controllers/AdminController.php`
    - Méthodes principales :
        - `demandes()` : liste tous les utilisateurs avec le rôle `entrepreneur_en_attente`.
        - `approuver($id)` : change le rôle de l'utilisateur en `entrepreneur_approuve`.
        - `refuser($id)` : supprime ou refuse la demande (bonus).

2. **Explications**
    - L'admin accède à une page listant toutes les demandes en attente.
    - Il peut approuver une demande (l'utilisateur devient entrepreneur).
    - Il peut refuser une demande (l'utilisateur est supprimé ou marqué comme refusé).

La suite : ajout des routes et de la vue Blade pour lister et gérer les demandes.

---

## Ajout des routes d'administration

---

## Recherche publique stands/produits

Pour permettre aux visiteurs de rechercher facilement un stand ou un produit, une fonctionnalité de recherche a été ajoutée côté public :

1. **Formulaire de recherche**
    - Ajouté en haut de la page d’accueil (`resources/views/stands/index.blade.php`).
    - Permet de saisir un mot-clé pour rechercher à la fois dans les stands et les produits.

2. **Route dédiée**
    - Route GET `/recherche` ajoutée dans `routes/web.php` :
      ```php
      Route::get('/recherche', [\App\Http\Controllers\StandController::class, 'recherche'])->name('recherche');
      ```

3. **Contrôleur**
    - Nouvelle méthode `recherche(Request $request)` dans `StandController` :
        - Recherche dans `nom_stand` et `description` de la table `stands`.
        - Recherche dans `nom` et `description` de la table `produits`.
        - Les résultats sont transmis à la vue sous forme de deux collections : `$stands` et `$produits`.

4. **Vue des résultats**
    - Fichier `resources/views/recherche.blade.php` créé.
    - Affiche les résultats trouvés dans les stands et/ou produits, avec liens vers leurs fiches détaillées.
    - Message si aucun résultat trouvé.

**Exemple d’utilisation** :
- Un visiteur tape "pizza" dans le champ de recherche : il verra tous les stands et produits contenant "pizza" dans leur nom ou description.

Cette fonctionnalité améliore l’expérience utilisateur en facilitant la découverte des offres sur la plateforme.

---

- Les routes pour la gestion des demandes d'entrepreneurs sont regroupées dans un préfixe `/admin` et protégées par deux middlewares :
    - `auth` : l'utilisateur doit être connecté
    - `admin` : l'utilisateur doit avoir le rôle `admin` (middleware à créer)
- Trois routes principales :
    - `GET /admin/demandes` : liste toutes les demandes en attente
    - `POST /admin/demandes/{id}/approuver` : approuve une demande
    - `POST /admin/demandes/{id}/refuser` : refuse une demande
- Ces routes appellent les méthodes du contrôleur `AdminController`.

Cela garantit que seule l'administration peut valider ou refuser les inscriptions d'entrepreneurs.

---

## Middleware admin

- Un middleware `AdminMiddleware` a été créé dans `app/Http/Middleware/AdminMiddleware.php`.
- Il vérifie que l'utilisateur est connecté et possède le rôle `admin` ; sinon, il retourne une erreur 403 (accès interdit).
- Ce middleware protège toutes les routes du groupe `/admin`.

**Exemple d'utilisation dans `routes/web.php`** :
```php
Route::middleware(['auth', 'admin'])->prefix('admin')->name('admin.')->group(function () {
    // ... routes admin ...
});
```

Il faut ensuite enregistrer ce middleware dans `app/Http/Kernel.php` dans la propriété `$routeMiddleware` :
```php
'admin' => \App\Http\Middleware\AdminMiddleware::class,
```

---

## Vue Blade admin : gestion des demandes

- La vue `resources/views/admin/demandes.blade.php` permet à l'administrateur de voir la liste des entrepreneurs en attente de validation.
- Pour chaque demande, il est possible d'approuver ou de refuser via deux boutons (formulaires POST protégés par @csrf).
- Les messages de succès ou d'erreur sont affichés en haut de la page.

### Gestion du motif de refus (bonus)

- Lors du rejet d'une demande, un champ texte "Motif du refus" est désormais obligatoire dans le formulaire de refus.
- Ce motif est enregistré dans le champ `motif_refus` de l'utilisateur.
- Le rôle de l'utilisateur passe à `entrepreneur_refuse` (l'utilisateur n'est plus supprimé).
- Le motif pourra être affiché ou utilisé pour notifier l'utilisateur refusé.
- Exemple d'utilisation dans la vue :
```blade
<form action="{{ route('admin.demandes.refuser', $user->id) }}" method="POST">
    @csrf
    <input type="text" name="motif_refus" placeholder="Motif du refus" required>
    <button type="submit">Refuser</button>
</form>
```
- Dans le contrôleur :
```php
public function refuser($id, Request $request)
{
    $user = User::findOrFail($id);
    $motif = $request->input('motif_refus');
    $user->motif_refus = $motif;
    $user->role = 'entrepreneur_refuse';
    $user->save();
    return redirect()->route('admin.demandes')->with('error', 'Demande refusée avec motif.');
}
```

- Si aucune demande n'est en attente, un message l'indique.

La vue hérite du layout principal `layouts.app` pour garder la cohérence graphique du site.

---

## Configuration de l'envoi d'emails (notifications)

Pour permettre l'envoi d'emails automatiques (par exemple lors du refus d'une demande entrepreneur), il faut configurer les paramètres SMTP dans le fichier `.env` à la racine du projet Laravel.

**Exemple de configuration pour un compte Gmail :**
```env
MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=faaz.gmof.ripm.knes@gmail.com
MAIL_PASSWORD=faaz gmof ripm knes
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=faaz.gmof.ripm.knes@gmail.com
MAIL_FROM_NAME="Eat&Drink"
```
- Remplace les valeurs par celles de ton compte d'envoi si besoin.
- Pour Gmail, il peut être nécessaire d'utiliser un mot de passe d'application ou d'activer les accès moins sécurisés.
- Après modification, redémarre le serveur Laravel pour prendre en compte les changements.

**Utilisation :**
- L'email de refus est envoyé automatiquement via le Mailable `RefusDemandeMail` lors du rejet d'une demande entrepreneur.
- Le contenu du mail est personnalisable dans `resources/views/emails/refus_demande.blade.php`.

---

## Interface publique : liste des stands

- Création du contrôleur `StandController` avec la méthode `index()` pour afficher tous les stands (relation avec l'utilisateur/entreprise exposant).
- Route publique `/` pointant vers cette méthode, remplaçant la page d'accueil par défaut.
- Vue Blade `stands/index.blade.php` listant chaque stand dans une carte avec nom, description et nom de l'entreprise exposante.
- Préparation du lien "Voir les produits" (sera relié à la page stand détaillée dans une prochaine étape).

Cette page constitue la porte d'entrée pour les visiteurs et participants de l'événement Eat&Drink.

---

## CRUD Produits pour entrepreneurs

1. **Contrôleur ProduitController**
    - Méthodes :
        - `index()` : liste les produits de l'entrepreneur connecté
        - `create()` et `store()` : formulaire et enregistrement d'un nouveau produit
        - `edit()` et `update()` : modification d'un produit existant
        - `destroy()` : suppression d'un produit
    - Sécurisation : seule la personne propriétaire du stand peut gérer ses produits (vérification dans chaque action)

2. **Routes**
    - Groupe de routes `/produits` protégé par les middlewares `auth` et `entrepreneur` (middleware à créer)
    - Routes :
        - `GET /produits` : liste
        - `GET /produits/create` : formulaire ajout
        - `POST /produits` : enregistrement
        - `GET /produits/{id}/edit` : formulaire édition
        - `PUT /produits/{id}` : modification
        - `DELETE /produits/{id}` : suppression

3. **Sécurisation**
    - Il faut créer un middleware `entrepreneur` pour s'assurer que seul un entrepreneur approuvé a accès à ces routes.

La suite : création du middleware et des vues Blade pour la gestion des produits.

---

## Vues Blade pour la gestion des produits (CRUD)

- Trois vues principales créées dans `resources/views/produits/` :
    - `index.blade.php` : liste tous les produits de l'entrepreneur, avec boutons modifier/supprimer et lien d'ajout
    - `create.blade.php` : formulaire d'ajout d'un produit
    - `edit.blade.php` : formulaire de modification d'un produit existant
- Les formulaires affichent les erreurs de validation et reprennent les valeurs précédemment saisies en cas d'erreur
- Les actions sont protégées par @csrf et utilisent les routes nommées définies dans `web.php`
- Les messages de succès sont affichés en haut de page après chaque opération

Chaque vue hérite du layout principal `layouts.app` pour une cohérence graphique.

---

## Panier et commandes (logique back, sans style)

- Mise en place d'un contrôleur `PanierController` pour gérer le panier en session :
    - `index()` : affiche le panier (liste des produits, quantités, total)
    - `ajouter($id)` : ajoute un produit au panier (POST, quantité personnalisable)
    - `modifier($id)` : modifie la quantité d'un produit (POST)
    - `supprimer($id)` : retire un produit du panier (POST)
    - `valider()` : simule la validation du panier (POST, commande à implémenter)
- Utilisation de la session Laravel pour stocker le panier sous forme de tableau `[produit_id => quantité]`.
- Création des routes publiques `/panier`, `/panier/ajouter/{id}`, `/panier/modifier/{id}`, `/panier/supprimer/{id}`, `/panier/valider`.
- Vue minimaliste `panier/index.blade.php` pour afficher, modifier et valider le panier (sans style, juste HTML fonctionnel).

La création effective des commandes (sauvegarde en base, gestion utilisateur/stand) a été réalisée comme suit :

---

## Commandes et vitrine publique (Module 4)

- **Vitrine publique** : accessible à tous, liste tous les stands approuvés sur la page d’accueil (« Nos Exposants »).
- **Page stand** : chaque stand possède une page dédiée affichant ses informations et la liste de ses produits.
- **Fiche produit** : chaque produit est consultable individuellement.
- **Panier** : les visiteurs peuvent ajouter des produits de plusieurs stands à leur panier (stocké en session).
- **Validation de commande** :
    - Lors de la validation, une commande distincte est créée pour chaque stand concerné.
    - Les détails de commande sont enregistrés au format JSON dans la base.
    - Si l’utilisateur est connecté, la commande est liée à son compte (`user_id`).
    - Les commandes sont datées et consultables par l’utilisateur (historique) et par l’admin (par stand).
- **Aucune logique de paiement n’est incluse** (conforme au cahier des charges TP).

---

# FIN DE LA DOCUMENTATION BACKEND

Le backend est complet, modulaire, et prêt pour le branchement d’un front stylisé ou d’API supplémentaires.
